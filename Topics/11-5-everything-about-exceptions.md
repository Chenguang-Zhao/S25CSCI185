---
description: Error handling is just part of life when it comes to writing code.
ms.custom: contributor-KevinMarquette
ms.date: 06/20/2024
title: Everything you wanted to know about exceptions
---
# Everything you wanted to know about exceptions

Error handling is just part of life when it comes to writing code. We can often check and validate
conditions for expected behavior. When the unexpected happens, we turn to exception handling. You
can easily handle exceptions generated by other people's code or you can generate your own
exceptions for others to handle.

> [!NOTE]
> The [original version][07] of this article appeared on the blog written by [@KevinMarquette][08].
> The PowerShell team thanks Kevin for sharing this content with us. Please check out his blog at
> [PowerShellExplained.com][05].

## Basic terminology

We need to cover some basic terms before we jump into this one.

### Exception

An Exception is like an event that is created when normal error handling can't deal with the issue.
Trying to divide a number by zero or running out of memory are examples of something that creates an
exception. Sometimes the author of the code you're using creates exceptions for certain issues
when they happen.

### Throw and Catch

When an exception happens, we say that an exception is thrown. To handle a thrown exception, you
need to catch it. If an exception is thrown and it isn't caught by something, the script stops
executing.

### The call stack

The call stack is the list of functions that have called each other. When a function is called, it
gets added to the stack or the top of the list. When the function exits or returns, it is removed
from the stack.

When an exception is thrown, that call stack is checked in order for an exception handler to catch
it.

### Terminating and non-terminating errors

An exception is generally a terminating error. A thrown exception is either be caught or it
terminates the current execution. By default, a non-terminating error is generated by `Write-Error`
and it adds an error to the output stream without throwing an exception.

I point this out because `Write-Error` and other non-terminating errors do not trigger the
`catch`.


## Basic command syntax

Here is a quick overview of the basic exception handling syntax used in PowerShell.

### Throw

To create our own exception event, we throw an exception with the `throw` keyword.

```powershell
function Start-Something
{
    throw "Bad thing happened"
}
```

This creates a runtime exception that is a terminating error. It's handled by a `catch` in a
calling function or exits the script with a message like this.

```powershell
PS> Start-Something

Bad thing happened
At line:1 char:1
+ throw "Bad thing happened"
+ ~~~~~~~~~~~~~~~~~~~~~~~~~~
    + CategoryInfo          : OperationStopped: (Bad thing happened:String) [], RuntimeException
    + FullyQualifiedErrorId : Bad thing happened
```

#### Write-Error -ErrorAction Stop

I mentioned that `Write-Error` doesn't throw a terminating error by default. If you specify
`-ErrorAction Stop`, `Write-Error` generates a terminating error that can be handled with a
`catch`.

```powershell
Write-Error -Message "Houston, we have a problem." -ErrorAction Stop
```


#### Cmdlet -ErrorAction Stop

If you specify `-ErrorAction Stop` on any advanced function or cmdlet, it turns all `Write-Error`
statements into terminating errors that stop execution or that can be handled by a `catch`.

```powershell
Start-Something -ErrorAction Stop
```


### Try/Catch

The way exception handling works in PowerShell (and many other languages) is that you first `try` a
section of code and if it throws an error, you can `catch` it. Here is a quick sample.

```powershell
try
{
    Start-Something
}
catch
{
    Write-Output "Something threw an exception"
    Write-Output $_
}

try
{
    Start-Something -ErrorAction Stop
}
catch
{
    Write-Output "Something threw an exception or used Write-Error"
    Write-Output $_
}
```

The `catch` script only runs if there's a terminating error. If the `try` executes correctly, then
it skips over the `catch`. You can access the exception information in the `catch` block using the
`$_` variable.

## Working with exceptions

There is more to exceptions than the basic syntax and exception properties.

### Catching typed exceptions

You can be selective with the exceptions that you catch. Exceptions have a type and you can specify
the type of exception you want to catch.

```powershell
try
{
    Start-Something -Path $path
}
catch [System.IO.FileNotFoundException]
{
    Write-Output "Could not find $path"
}
catch [System.IO.IOException]
{
        Write-Output "IO error with the file: $path"
}
```

The exception type is checked for each `catch` block until one is found that matches your exception.
It's important to realize that exceptions can inherit from other exceptions. In the example above,
`FileNotFoundException` inherits from `IOException`. So if the `IOException` was first, then it
would get called instead. Only one catch block is invoked even if there are multiple matches.

If we had a `System.IO.PathTooLongException`, the `IOException` would match but if we had an
`InsufficientMemoryException` then nothing would catch it and it would propagate up the stack.

### Catch multiple types at once

It's possible to catch multiple exception types with the same `catch` statement.

```powershell
try
{
    Start-Something -Path $path -ErrorAction Stop
}
catch [System.IO.DirectoryNotFoundException],[System.IO.FileNotFoundException]
{
    Write-Output "The path or file was not found: [$path]"
}
catch [System.IO.IOException]
{
    Write-Output "IO error with the file: [$path]"
}
```

Thank you Redditor `u/Sheppard_Ra` for suggesting this addition.

### Throwing typed exceptions

You can throw typed exceptions in PowerShell. Instead of calling `throw` with a string:

```powershell
throw "Could not find: $path"
```

Use an exception accelerator like this:

```powershell
throw [System.IO.FileNotFoundException] "Could not find: $path"
```

But you have to specify a message when you do it that way.

You can also create a new instance of an exception to be thrown. The message is optional when you do
this because the system has default messages for all built-in exceptions.

```powershell
throw [System.IO.FileNotFoundException]::new()
throw [System.IO.FileNotFoundException]::new("Could not find path: $path")
```

If you're not using PowerShell 5.0 or higher, you must use the older `New-Object` approach.

```powershell
throw (New-Object -TypeName System.IO.FileNotFoundException )
throw (New-Object -TypeName System.IO.FileNotFoundException -ArgumentList "Could not find path: $path")
```

By using a typed exception, you (or others) can catch the exception by the type as mentioned in the
previous section.

#### Write-Error -Exception

We can add these typed exceptions to `Write-Error` and we can still `catch` the errors by exception
type. Use `Write-Error` like in these examples:

```powershell
# with normal message
Write-Error -Message "Could not find path: $path" -Exception ([System.IO.FileNotFoundException]::new()) -ErrorAction Stop

# With message inside new exception
Write-Error -Exception ([System.IO.FileNotFoundException]::new("Could not find path: $path")) -ErrorAction Stop

# Pre PS 5.0
Write-Error -Exception ([System.IO.FileNotFoundException]"Could not find path: $path") -ErrorAction Stop

Write-Error -Message "Could not find path: $path" -Exception (New-Object -TypeName System.IO.FileNotFoundException) -ErrorAction Stop
```

Then we can catch it like this:

```powershell
catch [System.IO.FileNotFoundException]
{
    Write-Log $PSItem.ToString()
}
```

## Closing remarks

Adding proper exception handling to your scripts not only make them more stable, but also makes it
easier for you to troubleshoot those exceptions.

I spent a lot of time talking `throw` because it is a core concept when talking about exception
handling. PowerShell also gave us `Write-Error` that handles all the situations where you would use
`throw`. So don't think that you need to be using `throw` after reading this.

Now that I have taken the time to write about exception handling in this detail, I'm going to switch
over to using `Write-Error -Stop` to generate errors in my code. I'm also going to take Kirk's
advice and make `ThrowTerminatingError` my goto exception handler for every function.

<!-- link references -->
[01]: /dotnet/api
[02]: /dotnet/api/System.IO.FileNotFoundException
[03]: /powershell/module/microsoft.powershell.core/about/about_commonparameters
[04]: /powershell/module/microsoft.powershell.core/about/about_preference_variables
[05]: https://powershellexplained.com/
[06]: https://powershellexplained.com/2017-04-07-all-dotnet-exception-list
[07]: https://powershellexplained.com/2017-04-10-Powershell-exceptions-everything-you-ever-wanted-to-know/
[08]: https://twitter.com/KevinMarquette
